### 백준 1654 랜선 자르기

1. 문제 설명:

    이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)

    편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.

2. 풀이 방법:

    이분 탐색은 탐색 범위를 좁혀나가면서 값을 찾아가는 방법이다. 이 문제에서는 최소 길이와 최대 길이를 이용하여 mid 값을 구하고, mid 값을 기준으로 랜선을 자르고 잘린 랜선의 개수를 구한다. 그 후 잘린 랜선의 개수가 필요한 랜선의 개수 이상인지 검사하고 이분 탐색 범위를 좁힌다. 마지막에 탐색 범위가 더이상 좁혀지지 않을 때의 e값이 가장 긴 랜선의 길이가 된다.

3. 코드:
```python
#이분탐색에 대해서 자세히 공부하자..
import sys

K, N = map(int, sys.stdin.readline().split())
lans = []
for _ in range(K):
    lans.append(int(sys.stdin.readline()))

s = 1
e = max(lans)
while (s <= e):
    mid = (s + e) // 2
    cnt = 0
    for i in lans:
        cnt += i // mid

    if (cnt >= N):
        s = mid + 1
    else:
        e = mid - 1

print(e)
```
***
### 백준 2805 나무 자르기

1. 문제 설명:

    목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.

    상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.

2. 풀이 방법:

    이분 탐색 알고리즘을 사용하여 결과값을 구할 수 있다. 이분 탐색을 활용하는 이유는 위 문제와 같으니 생략,,

3. 코드:
```python
#쉽지 않은 이분탐색..
import sys

N, M = map(int, sys.stdin.readline().split())
trees = list(map(int, sys.stdin.readline().split()))
trees.sort()

s = 1
e = max(trees)

while (s <= e):
    mid = (s + e) // 2
    
    cnt = 0
    for i in trees:
        if (i > mid):
            cnt += i - mid

    if (cnt >= M):
        s = mid + 1
    else:
        e = mid - 1

print(e)
```
***
### 백준 2110 공유기 설치

1. 문제 설명:

    도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.

    도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.

    C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.

2. 풀이 방법:

    마지막으로 공유기를 설치한 위치와 현재 집 사이의 거리를 사용하여 이분 탐색을 수행해야 한다. 위의 원리를 이해한다면 이후 이분 탐색을 수행하는 방식은 위 문제와 동일.

3. 코드:
```python
#이분탐색... 도저히 모르겠다 진짜 제대로 공부할 필요성을 느낌
import sys

N, C = map(int, sys.stdin.readline().split())

homes = []
for _ in range(N):
    homes.append(int(sys.stdin.readline()))
homes.sort()

s = 1
e = homes[-1] - homes[0]

while (s <= e):
    mid = (s + e) // 2
    cnt = 1
    cur = homes[0]

    for i in range(1, N):
        if (homes[i] - cur >= mid):
            cnt += 1
            cur = homes[i]

    if (cnt >= C):
        s = mid + 1
    else:
        e = mid - 1

print(e)
```
***
### 백준 20920 영단어 암기는 괴로워

1. 문제 설명:

    화은이는 이번 영어 시험에서 틀린 문제를 바탕으로 영어 단어 암기를 하려고 한다. 그 과정에서 효율적으로 영어 단어를 외우기 위해 영어 단어장을 만들려 하고 있다. 화은이가 만들고자 하는 단어장의 단어 순서는 다음과 같은 우선순위를 차례로 적용하여 만들어진다.

    1. 자주 나오는 단어일수록 앞에 배치한다.
    2. 해당 단어의 길이가 길수록 앞에 배치한다.
    3. 알파벳 사전 순으로 앞에 있는 단어일수록 앞에 배치한다
 
    $M$보다 짧은 길이의 단어의 경우 읽는 것만으로도 외울 수 있기 때문에 길이가 $M$이상인 단어들만 외운다고 한다. 화은이가 괴로운 영단어 암기를 효율적으로 할 수 있도록 단어장을 만들어 주자.

2. 풀이 방법:

    sorted() 함수를 사용하면 다중 조건 정렬이 가능하다. lambda 함수를 사용하여 여러 정렬 조건들을 괄호로 묶어서 입력하면 해당 조건들에 맞게 다중 조건 정렬이 수행된다. 딕셔너리를 사용하여 단어의 빈도 수를 함께 저장하여 1번 조건으로 정렬하는 데에 필요한 정보를 얻는다.

3. 코드:
```python
#sorted() 함수 + lambda 함수를 사용하면 다중 조건 정렬이 가능하다. lambda 및 정렬의 key에 대해서 공부하자.
import sys

N, M = map(int, sys.stdin.readline().split())

words = {}
for _ in range(N):
    temp = sys.stdin.readline().strip()
    if (len(temp) >= M):
        if (temp in words):
            words[temp] += 1
        else:
            words[temp] = 1

words = sorted(words.items(), key = lambda x : (-x[1], -len(x[0]), x[0]))

for i in words:
    print(i[0])
```
***
### 백준 2447 별 찍기 - 10

1. 문제 설명:

    재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.

    크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.

    ***
    /* *
    ***
    
    N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.

2. 풀이 방법:

    예제 출력 1을 보면 N이 9일 때의 결과가 3 x 3으로 9번 출력 된 것을 볼 수 있다. 마찬가지로 N이 9일 때의 결과를 보면 N이 3일 때의 결과가 3 x 3으로 9번 출력되어 있다. 이러한 규칙을 바탕으로 재귀함수를 구현하여 문제를 해결할 수 있다.

3. 코드:
```python
#재미있는 문제.
import sys

def drawStar(x):
    if (x == 1):
        return '*'
    
    result = []
    temp = drawStar(x // 3)

    for i in temp:
        result.append(i * 3)
    for i in temp:
        result.append(i + ' ' * (len(i)) + i)
    for i in temp:
        result.append(i * 3)
    return result

N = int(sys.stdin.readline())

print('\n'.join(drawStar(N)))
```
***
### 백준 11729 하노이 탑 이동 순서

1. 문제 설명:

    세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.

    1. 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
    2. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.

    이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.

2. 풀이 방법:

    재귀함수를 구현하여 문제를 해결할 수 있다. 문제 해결을 위한 과정은 다음과 같다.
    1. N번의 원반을 목적지로 옮기기 위해 N-1까지의 원반을 경유지로 옮긴다.
    2. N번째의 원반을 목적지로 옮긴다.
    3. 경유지에 있는 N-1까지의 원반을 목적지로 옮긴다.

    이를 재귀함수로 나타내면 다음과 같다.
    N이 1인 경우: 
        1번 원반을 현재 위치에서 목적지로 이동
    N이 1이 아닌 경우:
        N-1번까지의 원반을 경유지로 이동
        N번 원반을 목적지로 이동
        N-1번까지의 원반을 목적지에서 경유지로 이동

3. 코드:
```python
#근데 이거 N 값의 범위가 1~20인데 N이 20일 경우 시간 복잡도가 너무 커지는데 이게 맞나..?
import sys

def hanoi(N, start, mid, end):
    if (N == 1):
        print(start, end)
        return
    else:
        hanoi(N - 1, start, end, mid)
        print(start, end)
        hanoi(N - 1, mid, start, end)

N = int(sys.stdin.readline())

print(2 ** N -1)
hanoi(N, 1, 2, 3)
```
***